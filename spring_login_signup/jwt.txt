 앱에서 로그아웃을 하지 않는 이상 로그인을 유지하기위해 jwt사용. 
 일반적으로는 Session을 이용해서 클라이언트와 서버 통신 중 Stateless 무상태의 단점을 보완할 수 있었지만, 모바일의 특성상 자주 끊길 소지가 있음 
 
JSON Web Token(JWT)은 JSON 객체로서 당사자 간에 안전하게 정보를 전송할 수 있는 작고 독립적인 방법을 정의하는 공개 표준 (RFC 7519) 
JWT는 Claim based Token(사용자에 대한 프로퍼티/속성) 이다.
서버와 클라이언트 사이에서 JSON 객체를 이용해 Self-contained(토큰자체가 정보/ key,value) 방식으로 정보를 안전한게 전달
회원 인증, 정보 전달에 주로 사용

JWT는 암호 (HMAC 알고리즘 사용) 또는 RSA를 사용하는 공용 /개인 키 쌍을 사용하여 서명을 할 수 있다
그러나 대표적인 취약점은 발행된 토큰을 제거할 수 없다.(기간 만료 제외) 이러한 이유 때문에 Blacklist를 만들어 관리. 로그아웃시 jwt를 blacklist라는 db테이블에 넣어 해당토큰의 이용을 막는다

일반적으로 모바일 애플리케이션과 백엔드 간 인증은 JWT 토큰을 이용하여 수행
별도의 로그인 end point 를 만들고 로그인을 수행해야 하니 기본적으로 아이디와 비밀번호를 앱에서 서버로 보내야함
전달받은 아이디와 비밀번호를 이용하여 로그인 성공 또는 실패를 구현하고, 로그인 성공시 JWT 토큰을 생성하여 클라이언트로 보냄
일반적으로 JWT 토큰 생성시 사용자 식별 정보와 토큰의 만료시간이 포함됨
로그인 성공 후에 서버로부터 전달받은 JWT 를 앱에서 보관, 이후 권한이 필요한 백엔드 API 호출시 JWT 토큰을 첨부하여 서버에 전달

JWT 인증을 이용한 게시글 작성 API 호출 시나리오
1.앱 실행
2.로그인 수행
3.로그인 성공시 서버로부터 전달받은 JWT 토큰을 보관
4.게시글 작성화면 진입
5.게시글 작성에 필요한 데이터와 로그인 성공시 전달받은 JWT 토큰을 서버에 함께 전송
6.서버에서는 JWT 토큰을 검증 (유효한 토큰인지 -> 유효시간 및 사용자 유효성 체크) 하여 성공시 게시글 작성 및 응답

JWT 토큰을 전달하는 두가지 방법
1.RequestHeader 에 토큰을 담아 서버로 전달
2.End point url 파라미터에 토큰을 담아 서버로 전달

인증이 필요한 API 호출시에도 크게 2가지 스타일로 구현
1. Retrofit 의 Interceptor 를 구현하여 인증이 필요한 API 요청마다 JWT 토큰을 요청 헤더에 포함하여 전달
2. Retrofit Rest Api 를 수행하는 별도의 Executor 클래스를 작성하여 인증이 필요한 API 호출시에 토큰을 포함하여 전달 (URL 파라미터 이용)

서버측에서도 여러가지 방법이 있으나, 스프링을 이용하여 JWT 토큰 관련 처리를 수행할 때는 Filter 를 등록하여 처리
1.인증이 필요한 API 분류
2.해당 API 호출시 요청 헤더에 JWT 토큰이 존재하는지 확인
3.인증 후 처리

JWT의 기본구조
Header . Payload . Signature

1. Header
JWT 웹 토큰의 헤더 정보

typ : 토큰의 타입, JWT만 존재
alg : 해싱 알고리즘. (HMAC SHA256 or RSA). 헤더를 암호화 하는게 아니다. 토큰 검증시 사용.
{
     "typ" : "JWT"
     "alg" : "HS256",
}


2. Payload
실제 토큰으로 사용하려는 데이터가 담기는 부분. 각 데이터를 Claim이라고 함

iss (String) : issuer, 토큰 발행자 정보
exp (Number) : expiration time, 만료일
sub (String) : subject, 제목
aud (String) : audience,

Public claims : 사용자 정의 Claim. 
Public 이라는 이름처럼 공개용 정보
충돌 방지를 위해 URI 포맷을 이용해 저장한다.

Private claims : 사용자 정의 Claim
Public claims 과 다르게 사용자가 임의로 정한 정보


3. Signature
Header 와 Payload의 데이터 무결성과 변조 방지를 위한 서명 
Header + Payload 를 합친 후, Secret 키와 함께 Header의 해싱 알고리즘으로 인코딩

HMACSHA256(
  base64UrlEncode(header) + "." +
  base64UrlEncode(payload),
  secret)


JWT 구조
JWT는 [Header Payload Signature] 각각 JSON 형태의 데이터를 base 64 인코딩 후 합침
최종적으로 만들어진 토큰은 HTTP 통신 간 이용되며, Authorization 이라는 key의 value로서 사용됨
아래와 같은 순서로 . 을 이용해 합침
header.payload.signature

JWT인증과정
1. Client가 Server에 POST 방식으로 로그인.
2. Server에서 시크릿키와함께 토큰을생성
3. Server에서 Client로 토큰을 리턴
4. Client에서 Server로 헤더 토큰과 함께 요청
5. Server에서 토큰 Signature 확인
6. Server에서 Client로 응답

JWT 단점
1. Self-contained : 토큰 자체에 정보가 있다는 사실은 양날의 검이 될수 있음
2. 토큰 길이 : 토큰 자체 payload 에 Claim set을 저장하기 때문에 정보가 많아질수록 토큰의 길이가 늘어나 네트워크에 부하를 줄 수 있음
3. payload 암호화 : payload 자체는 암호화 되지 않고 base64로 인코딩한 데이터 
중간에 payload를 탈취하면 디코딩을 통해 테이터를 볼 수 있음 
JWE 를 통해 암호하하거나, payload에 중요 데이터를 넣지 않아야 함

4. Stateless : 무상태성. 토큰은 한번 만들면 서버에서 제어가 불가능. 
토큰을 임의로 삭제할 수 있는 방법이 없기 때문에 토큰 만료시간을 꼭 넣어주는게 좋음.

5. tore Token : 토큰은 클라이언트 side에서 관리해야하기 때문에 토큰을 저장해야함.


<!-- JWT 디펜던시-->
<dependency>
	<groupId>io.jsonwebtoken</groupId>
	<artifactId>jjwt</artifactId>
	<version>0.7.0</version>
</dependency>

참고
https://alwayspr.tistory.com/8
